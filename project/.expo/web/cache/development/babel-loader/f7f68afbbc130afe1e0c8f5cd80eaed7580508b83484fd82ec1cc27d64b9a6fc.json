{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nimport FieldPath from \"../FieldPath\";\nimport { isObject, isString } from \"../../../utils\";\nvar buildFieldPathData = function buildFieldPathData(segments, value) {\n  if (segments.length === 1) {\n    return _defineProperty({}, segments[0], value);\n  }\n  return _defineProperty({}, segments[0], buildFieldPathData(segments.slice(1), value));\n};\nexport var mergeFieldPathData = function mergeFieldPathData(data, segments, value) {\n  if (segments.length === 1) {\n    return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, segments[0], value));\n  }\n  if (data[segments[0]]) {\n    return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, segments[0], mergeFieldPathData(data[segments[0]], segments.slice(1), value)));\n  }\n  return _objectSpread(_objectSpread({}, data), {}, _defineProperty({}, segments[0], buildFieldPathData(segments.slice(1), value)));\n};\nexport var parseUpdateArgs = function parseUpdateArgs(args, methodName) {\n  var data = {};\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(`${methodName} failed: If using a single update argument, it must be an object.`);\n    }\n    var _args = _slicedToArray(args, 1);\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error(`${methodName} failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.`);\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(`${methodName} failed: Argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n  return data;\n};","map":{"version":3,"names":["FieldPath","isObject","isString","buildFieldPathData","segments","value","length","_defineProperty","slice","mergeFieldPathData","data","_objectSpread","parseUpdateArgs","args","methodName","Error","_args","_slicedToArray","i","key","_segments"],"sources":["C:/Users/Johnny Hermitano/Documents/GitHub/sofdes_watermelon/project/node_modules/react-native-firebase/dist/modules/firestore/utils/index.js"],"sourcesContent":["import FieldPath from '../FieldPath';\nimport { isObject, isString } from '../../../utils';\n\nconst buildFieldPathData = (segments, value) => {\n  if (segments.length === 1) {\n    return {\n      [segments[0]]: value\n    };\n  }\n\n  return {\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n}; // eslint-disable-next-line import/prefer-default-export\n\n\nexport const mergeFieldPathData = (data, segments, value) => {\n  if (segments.length === 1) {\n    return { ...data,\n      [segments[0]]: value\n    };\n  }\n\n  if (data[segments[0]]) {\n    return { ...data,\n      [segments[0]]: mergeFieldPathData(data[segments[0]], segments.slice(1), value)\n    };\n  }\n\n  return { ...data,\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n};\nexport const parseUpdateArgs = (args, methodName) => {\n  let data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(`${methodName} failed: If using a single update argument, it must be an object.`);\n    }\n\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(`${methodName} failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.`);\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(`${methodName} failed: Argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n\n  return data;\n};"],"mappings":";;;;AAAA,OAAOA,SAAS;AAChB,SAASC,QAAQ,EAAEC,QAAQ;AAE3B,IAAMC,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIC,QAAQ,EAAEC,KAAK,EAAK;EAC9C,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IACzB,OAAAC,eAAA,KACGH,QAAQ,CAAC,CAAC,CAAC,EAAGC,KAAK;EAExB;EAEA,OAAAE,eAAA,KACGH,QAAQ,CAAC,CAAC,CAAC,EAAGD,kBAAkB,CAACC,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,EAAEH,KAAK,CAAC;AAE/D,CAAC;AAGD,OAAO,IAAMI,kBAAkB,GAAG,SAArBA,kBAAkBA,CAAIC,IAAI,EAAEN,QAAQ,EAAEC,KAAK,EAAK;EAC3D,IAAID,QAAQ,CAACE,MAAM,KAAK,CAAC,EAAE;IACzB,OAAAK,aAAA,CAAAA,aAAA,KAAYD,IAAI,OAAAH,eAAA,KACbH,QAAQ,CAAC,CAAC,CAAC,EAAGC,KAAK;EAExB;EAEA,IAAIK,IAAI,CAACN,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE;IACrB,OAAAO,aAAA,CAAAA,aAAA,KAAYD,IAAI,OAAAH,eAAA,KACbH,QAAQ,CAAC,CAAC,CAAC,EAAGK,kBAAkB,CAACC,IAAI,CAACN,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,EAAEH,KAAK,CAAC;EAElF;EAEA,OAAAM,aAAA,CAAAA,aAAA,KAAYD,IAAI,OAAAH,eAAA,KACbH,QAAQ,CAAC,CAAC,CAAC,EAAGD,kBAAkB,CAACC,QAAQ,CAACI,KAAK,CAAC,CAAC,CAAC,EAAEH,KAAK,CAAC;AAE/D,CAAC;AACD,OAAO,IAAMO,eAAe,GAAG,SAAlBA,eAAeA,CAAIC,IAAI,EAAEC,UAAU,EAAK;EACnD,IAAIJ,IAAI,GAAG,CAAC,CAAC;EAEb,IAAIG,IAAI,CAACP,MAAM,KAAK,CAAC,EAAE;IACrB,IAAI,CAACL,QAAQ,CAACY,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;MACtB,MAAM,IAAIE,KAAK,CAAE,GAAED,UAAW,mEAAkE,CAAC;IACnG;IAAC,IAAAE,KAAA,GAAAC,cAAA,CAEQJ,IAAI;IAAZH,IAAI,GAAAM,KAAA;EACP,CAAC,MAAM,IAAIH,IAAI,CAACP,MAAM,GAAG,CAAC,KAAK,CAAC,EAAE;IAChC,MAAM,IAAIS,KAAK,CAAE,GAAED,UAAW,6GAA4G,CAAC;EAC7I,CAAC,MAAM;IACL,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAACP,MAAM,EAAEY,CAAC,IAAI,CAAC,EAAE;MACvC,IAAMC,GAAG,GAAGN,IAAI,CAACK,CAAC,CAAC;MACnB,IAAMb,KAAK,GAAGQ,IAAI,CAACK,CAAC,GAAG,CAAC,CAAC;MAEzB,IAAIhB,QAAQ,CAACiB,GAAG,CAAC,EAAE;QACjBT,IAAI,CAACS,GAAG,CAAC,GAAGd,KAAK;MACnB,CAAC,MAAM,IAAIc,GAAG,YAAYnB,SAAS,EAAE;QACnCU,IAAI,GAAGD,kBAAkB,CAACC,IAAI,EAAES,GAAG,CAACC,SAAS,EAAEf,KAAK,CAAC;MACvD,CAAC,MAAM;QACL,MAAM,IAAIU,KAAK,CAAE,GAAED,UAAW,8BAA6BI,CAAE,gCAA+B,CAAC;MAC/F;IACF;EACF;EAEA,OAAOR,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}