{"ast":null,"code":"import DocumentReference from \"../DocumentReference\";\nimport Blob from \"../Blob\";\nimport { DOCUMENT_ID } from \"../FieldPath\";\nimport FieldValue from \"../FieldValue\";\nimport GeoPoint from \"../GeoPoint\";\nimport Path from \"../Path\";\nimport { typeOf } from \"../../../utils\";\nimport Timestamp from \"../Timestamp\";\nexport var buildNativeMap = function buildNativeMap(data) {\n  var nativeData = {};\n  if (data) {\n    Object.keys(data).forEach(function (key) {\n      var typeMap = buildTypeMap(data[key]);\n      if (typeMap) {\n        nativeData[key] = typeMap;\n      }\n    });\n  }\n  return nativeData;\n};\nexport var buildNativeArray = function buildNativeArray(array) {\n  var nativeArray = [];\n  if (array) {\n    array.forEach(function (value) {\n      var typeMap = buildTypeMap(value);\n      if (typeMap) {\n        nativeArray.push(typeMap);\n      }\n    });\n  }\n  return nativeArray;\n};\nexport var buildTypeMap = function buildTypeMap(value) {\n  var type = typeOf(value);\n  if (Number.isNaN(value)) {\n    return {\n      type: 'nan',\n      value: null\n    };\n  }\n  if (value === Infinity) {\n    return {\n      type: 'infinity',\n      value: null\n    };\n  }\n  if (value === null || value === undefined) {\n    return {\n      type: 'null',\n      value: null\n    };\n  }\n  if (value === DOCUMENT_ID) {\n    return {\n      type: 'documentid',\n      value: null\n    };\n  }\n  if (type === 'boolean' || type === 'number' || type === 'string') {\n    return {\n      type: type,\n      value: value\n    };\n  }\n  if (type === 'array') {\n    return {\n      type: type,\n      value: buildNativeArray(value)\n    };\n  }\n  if (type === 'object') {\n    if (value instanceof DocumentReference) {\n      return {\n        type: 'reference',\n        value: value.path\n      };\n    }\n    if (value instanceof GeoPoint) {\n      return {\n        type: 'geopoint',\n        value: {\n          latitude: value.latitude,\n          longitude: value.longitude\n        }\n      };\n    }\n    if (value instanceof Timestamp) {\n      return {\n        type: 'timestamp',\n        value: {\n          seconds: value.seconds,\n          nanoseconds: value.nanoseconds\n        }\n      };\n    }\n    if (value instanceof Date) {\n      return {\n        type: 'date',\n        value: value.getTime()\n      };\n    }\n    if (value instanceof Blob) {\n      return {\n        type: 'blob',\n        value: value.toBase64()\n      };\n    }\n    if (value instanceof FieldValue) {\n      return {\n        type: 'fieldvalue',\n        value: {\n          elements: value.elements,\n          type: value.type\n        }\n      };\n    }\n    return {\n      type: 'object',\n      value: buildNativeMap(value)\n    };\n  }\n  console.warn(`Unknown data type received ${type}`);\n  return null;\n};\nexport var parseNativeMap = function parseNativeMap(firestore, nativeData) {\n  var data;\n  if (nativeData) {\n    data = {};\n    Object.keys(nativeData).forEach(function (key) {\n      data[key] = parseTypeMap(firestore, nativeData[key]);\n    });\n  }\n  return data;\n};\nvar parseNativeArray = function parseNativeArray(firestore, nativeArray) {\n  var array = [];\n  if (nativeArray) {\n    nativeArray.forEach(function (typeMap) {\n      array.push(parseTypeMap(firestore, typeMap));\n    });\n  }\n  return array;\n};\nvar parseTypeMap = function parseTypeMap(firestore, typeMap) {\n  var type = typeMap.type,\n    value = typeMap.value;\n  if (type === 'null') {\n    return null;\n  }\n  if (type === 'boolean' || type === 'number' || type === 'string') {\n    return value;\n  }\n  if (type === 'array') {\n    return parseNativeArray(firestore, value);\n  }\n  if (type === 'object') {\n    return parseNativeMap(firestore, value);\n  }\n  if (type === 'reference') {\n    return new DocumentReference(firestore, Path.fromName(value));\n  }\n  if (type === 'geopoint') {\n    return new GeoPoint(value.latitude, value.longitude);\n  }\n  if (type === 'timestamp') {\n    return new Timestamp(value.seconds, value.nanoseconds);\n  }\n  if (type === 'date') {\n    return new Date(value);\n  }\n  if (type === 'blob') {\n    return Blob.fromBase64String(value);\n  }\n  if (type === 'infinity') {\n    return Infinity;\n  }\n  if (type === 'nan') {\n    return NaN;\n  }\n  console.warn(`Unknown data type received ${type}`);\n  return value;\n};","map":{"version":3,"names":["DocumentReference","Blob","DOCUMENT_ID","FieldValue","GeoPoint","Path","typeOf","Timestamp","buildNativeMap","data","nativeData","Object","keys","forEach","key","typeMap","buildTypeMap","buildNativeArray","array","nativeArray","value","push","type","Number","isNaN","Infinity","undefined","path","latitude","longitude","seconds","nanoseconds","Date","getTime","toBase64","elements","console","warn","parseNativeMap","firestore","parseTypeMap","parseNativeArray","fromName","fromBase64String","NaN"],"sources":["C:/Users/Johnny Hermitano/Documents/GitHub/sofdes_watermelon/project/node_modules/react-native-firebase/dist/modules/firestore/utils/serialize.js"],"sourcesContent":["import DocumentReference from '../DocumentReference';\nimport Blob from '../Blob';\nimport { DOCUMENT_ID } from '../FieldPath';\nimport FieldValue from '../FieldValue';\nimport GeoPoint from '../GeoPoint';\nimport Path from '../Path';\nimport { typeOf } from '../../../utils';\nimport Timestamp from '../Timestamp';\n/*\n * Functions that build up the data needed to represent\n * the different types available within Firestore\n * for transmission to the native side\n */\n\nexport const buildNativeMap = data => {\n  const nativeData = {};\n\n  if (data) {\n    Object.keys(data).forEach(key => {\n      const typeMap = buildTypeMap(data[key]);\n\n      if (typeMap) {\n        nativeData[key] = typeMap;\n      }\n    });\n  }\n\n  return nativeData;\n};\nexport const buildNativeArray = array => {\n  const nativeArray = [];\n\n  if (array) {\n    array.forEach(value => {\n      const typeMap = buildTypeMap(value);\n\n      if (typeMap) {\n        nativeArray.push(typeMap);\n      }\n    });\n  }\n\n  return nativeArray;\n};\nexport const buildTypeMap = value => {\n  const type = typeOf(value);\n\n  if (Number.isNaN(value)) {\n    return {\n      type: 'nan',\n      value: null\n    };\n  }\n\n  if (value === Infinity) {\n    return {\n      type: 'infinity',\n      value: null\n    };\n  }\n\n  if (value === null || value === undefined) {\n    return {\n      type: 'null',\n      value: null\n    };\n  }\n\n  if (value === DOCUMENT_ID) {\n    return {\n      type: 'documentid',\n      value: null\n    };\n  }\n\n  if (type === 'boolean' || type === 'number' || type === 'string') {\n    return {\n      type,\n      value\n    };\n  }\n\n  if (type === 'array') {\n    return {\n      type,\n      value: buildNativeArray(value)\n    };\n  }\n\n  if (type === 'object') {\n    if (value instanceof DocumentReference) {\n      return {\n        type: 'reference',\n        value: value.path\n      };\n    }\n\n    if (value instanceof GeoPoint) {\n      return {\n        type: 'geopoint',\n        value: {\n          latitude: value.latitude,\n          longitude: value.longitude\n        }\n      };\n    }\n\n    if (value instanceof Timestamp) {\n      return {\n        type: 'timestamp',\n        value: {\n          seconds: value.seconds,\n          nanoseconds: value.nanoseconds\n        }\n      };\n    }\n\n    if (value instanceof Date) {\n      return {\n        type: 'date',\n        value: value.getTime()\n      };\n    }\n\n    if (value instanceof Blob) {\n      return {\n        type: 'blob',\n        value: value.toBase64()\n      };\n    } // TODO: Salakar: Refactor in v6 - add internal `type` flag\n\n\n    if (value instanceof FieldValue) {\n      return {\n        type: 'fieldvalue',\n        value: {\n          elements: value.elements,\n          type: value.type\n        }\n      };\n    }\n\n    return {\n      type: 'object',\n      value: buildNativeMap(value)\n    };\n  }\n\n  console.warn(`Unknown data type received ${type}`);\n  return null;\n};\n/*\n * Functions that parse the received from the native\n * side and converts to the correct Firestore JS types\n */\n\nexport const parseNativeMap = (firestore, nativeData) => {\n  let data;\n\n  if (nativeData) {\n    data = {};\n    Object.keys(nativeData).forEach(key => {\n      data[key] = parseTypeMap(firestore, nativeData[key]);\n    });\n  }\n\n  return data;\n};\n\nconst parseNativeArray = (firestore, nativeArray) => {\n  const array = [];\n\n  if (nativeArray) {\n    nativeArray.forEach(typeMap => {\n      array.push(parseTypeMap(firestore, typeMap));\n    });\n  }\n\n  return array;\n};\n\nconst parseTypeMap = (firestore, typeMap) => {\n  const {\n    type,\n    value\n  } = typeMap;\n\n  if (type === 'null') {\n    return null;\n  }\n\n  if (type === 'boolean' || type === 'number' || type === 'string') {\n    return value;\n  }\n\n  if (type === 'array') {\n    return parseNativeArray(firestore, value);\n  }\n\n  if (type === 'object') {\n    return parseNativeMap(firestore, value);\n  }\n\n  if (type === 'reference') {\n    return new DocumentReference(firestore, Path.fromName(value));\n  }\n\n  if (type === 'geopoint') {\n    return new GeoPoint(value.latitude, value.longitude);\n  }\n\n  if (type === 'timestamp') {\n    return new Timestamp(value.seconds, value.nanoseconds);\n  }\n\n  if (type === 'date') {\n    return new Date(value);\n  }\n\n  if (type === 'blob') {\n    return Blob.fromBase64String(value);\n  }\n\n  if (type === 'infinity') {\n    return Infinity;\n  }\n\n  if (type === 'nan') {\n    return NaN;\n  }\n\n  console.warn(`Unknown data type received ${type}`);\n  return value;\n};"],"mappings":"AAAA,OAAOA,iBAAiB;AACxB,OAAOC,IAAI;AACX,SAASC,WAAW;AACpB,OAAOC,UAAU;AACjB,OAAOC,QAAQ;AACf,OAAOC,IAAI;AACX,SAASC,MAAM;AACf,OAAOC,SAAS;AAOhB,OAAO,IAAMC,cAAc,GAAG,SAAjBA,cAAcA,CAAGC,IAAI,EAAI;EACpC,IAAMC,UAAU,GAAG,CAAC,CAAC;EAErB,IAAID,IAAI,EAAE;IACRE,MAAM,CAACC,IAAI,CAACH,IAAI,CAAC,CAACI,OAAO,CAAC,UAAAC,GAAG,EAAI;MAC/B,IAAMC,OAAO,GAAGC,YAAY,CAACP,IAAI,CAACK,GAAG,CAAC,CAAC;MAEvC,IAAIC,OAAO,EAAE;QACXL,UAAU,CAACI,GAAG,CAAC,GAAGC,OAAO;MAC3B;IACF,CAAC,CAAC;EACJ;EAEA,OAAOL,UAAU;AACnB,CAAC;AACD,OAAO,IAAMO,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAGC,KAAK,EAAI;EACvC,IAAMC,WAAW,GAAG,EAAE;EAEtB,IAAID,KAAK,EAAE;IACTA,KAAK,CAACL,OAAO,CAAC,UAAAO,KAAK,EAAI;MACrB,IAAML,OAAO,GAAGC,YAAY,CAACI,KAAK,CAAC;MAEnC,IAAIL,OAAO,EAAE;QACXI,WAAW,CAACE,IAAI,CAACN,OAAO,CAAC;MAC3B;IACF,CAAC,CAAC;EACJ;EAEA,OAAOI,WAAW;AACpB,CAAC;AACD,OAAO,IAAMH,YAAY,GAAG,SAAfA,YAAYA,CAAGI,KAAK,EAAI;EACnC,IAAME,IAAI,GAAGhB,MAAM,CAACc,KAAK,CAAC;EAE1B,IAAIG,MAAM,CAACC,KAAK,CAACJ,KAAK,CAAC,EAAE;IACvB,OAAO;MACLE,IAAI,EAAE,KAAK;MACXF,KAAK,EAAE;IACT,CAAC;EACH;EAEA,IAAIA,KAAK,KAAKK,QAAQ,EAAE;IACtB,OAAO;MACLH,IAAI,EAAE,UAAU;MAChBF,KAAK,EAAE;IACT,CAAC;EACH;EAEA,IAAIA,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKM,SAAS,EAAE;IACzC,OAAO;MACLJ,IAAI,EAAE,MAAM;MACZF,KAAK,EAAE;IACT,CAAC;EACH;EAEA,IAAIA,KAAK,KAAKlB,WAAW,EAAE;IACzB,OAAO;MACLoB,IAAI,EAAE,YAAY;MAClBF,KAAK,EAAE;IACT,CAAC;EACH;EAEA,IAAIE,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,QAAQ,EAAE;IAChE,OAAO;MACLA,IAAI,EAAJA,IAAI;MACJF,KAAK,EAALA;IACF,CAAC;EACH;EAEA,IAAIE,IAAI,KAAK,OAAO,EAAE;IACpB,OAAO;MACLA,IAAI,EAAJA,IAAI;MACJF,KAAK,EAAEH,gBAAgB,CAACG,KAAK;IAC/B,CAAC;EACH;EAEA,IAAIE,IAAI,KAAK,QAAQ,EAAE;IACrB,IAAIF,KAAK,YAAYpB,iBAAiB,EAAE;MACtC,OAAO;QACLsB,IAAI,EAAE,WAAW;QACjBF,KAAK,EAAEA,KAAK,CAACO;MACf,CAAC;IACH;IAEA,IAAIP,KAAK,YAAYhB,QAAQ,EAAE;MAC7B,OAAO;QACLkB,IAAI,EAAE,UAAU;QAChBF,KAAK,EAAE;UACLQ,QAAQ,EAAER,KAAK,CAACQ,QAAQ;UACxBC,SAAS,EAAET,KAAK,CAACS;QACnB;MACF,CAAC;IACH;IAEA,IAAIT,KAAK,YAAYb,SAAS,EAAE;MAC9B,OAAO;QACLe,IAAI,EAAE,WAAW;QACjBF,KAAK,EAAE;UACLU,OAAO,EAAEV,KAAK,CAACU,OAAO;UACtBC,WAAW,EAAEX,KAAK,CAACW;QACrB;MACF,CAAC;IACH;IAEA,IAAIX,KAAK,YAAYY,IAAI,EAAE;MACzB,OAAO;QACLV,IAAI,EAAE,MAAM;QACZF,KAAK,EAAEA,KAAK,CAACa,OAAO,CAAC;MACvB,CAAC;IACH;IAEA,IAAIb,KAAK,YAAYnB,IAAI,EAAE;MACzB,OAAO;QACLqB,IAAI,EAAE,MAAM;QACZF,KAAK,EAAEA,KAAK,CAACc,QAAQ,CAAC;MACxB,CAAC;IACH;IAGA,IAAId,KAAK,YAAYjB,UAAU,EAAE;MAC/B,OAAO;QACLmB,IAAI,EAAE,YAAY;QAClBF,KAAK,EAAE;UACLe,QAAQ,EAAEf,KAAK,CAACe,QAAQ;UACxBb,IAAI,EAAEF,KAAK,CAACE;QACd;MACF,CAAC;IACH;IAEA,OAAO;MACLA,IAAI,EAAE,QAAQ;MACdF,KAAK,EAAEZ,cAAc,CAACY,KAAK;IAC7B,CAAC;EACH;EAEAgB,OAAO,CAACC,IAAI,CAAE,8BAA6Bf,IAAK,EAAC,CAAC;EAClD,OAAO,IAAI;AACb,CAAC;AAMD,OAAO,IAAMgB,cAAc,GAAG,SAAjBA,cAAcA,CAAIC,SAAS,EAAE7B,UAAU,EAAK;EACvD,IAAID,IAAI;EAER,IAAIC,UAAU,EAAE;IACdD,IAAI,GAAG,CAAC,CAAC;IACTE,MAAM,CAACC,IAAI,CAACF,UAAU,CAAC,CAACG,OAAO,CAAC,UAAAC,GAAG,EAAI;MACrCL,IAAI,CAACK,GAAG,CAAC,GAAG0B,YAAY,CAACD,SAAS,EAAE7B,UAAU,CAACI,GAAG,CAAC,CAAC;IACtD,CAAC,CAAC;EACJ;EAEA,OAAOL,IAAI;AACb,CAAC;AAED,IAAMgC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAIF,SAAS,EAAEpB,WAAW,EAAK;EACnD,IAAMD,KAAK,GAAG,EAAE;EAEhB,IAAIC,WAAW,EAAE;IACfA,WAAW,CAACN,OAAO,CAAC,UAAAE,OAAO,EAAI;MAC7BG,KAAK,CAACG,IAAI,CAACmB,YAAY,CAACD,SAAS,EAAExB,OAAO,CAAC,CAAC;IAC9C,CAAC,CAAC;EACJ;EAEA,OAAOG,KAAK;AACd,CAAC;AAED,IAAMsB,YAAY,GAAG,SAAfA,YAAYA,CAAID,SAAS,EAAExB,OAAO,EAAK;EAC3C,IACEO,IAAI,GAEFP,OAAO,CAFTO,IAAI;IACJF,KAAK,GACHL,OAAO,CADTK,KAAK;EAGP,IAAIE,IAAI,KAAK,MAAM,EAAE;IACnB,OAAO,IAAI;EACb;EAEA,IAAIA,IAAI,KAAK,SAAS,IAAIA,IAAI,KAAK,QAAQ,IAAIA,IAAI,KAAK,QAAQ,EAAE;IAChE,OAAOF,KAAK;EACd;EAEA,IAAIE,IAAI,KAAK,OAAO,EAAE;IACpB,OAAOmB,gBAAgB,CAACF,SAAS,EAAEnB,KAAK,CAAC;EAC3C;EAEA,IAAIE,IAAI,KAAK,QAAQ,EAAE;IACrB,OAAOgB,cAAc,CAACC,SAAS,EAAEnB,KAAK,CAAC;EACzC;EAEA,IAAIE,IAAI,KAAK,WAAW,EAAE;IACxB,OAAO,IAAItB,iBAAiB,CAACuC,SAAS,EAAElC,IAAI,CAACqC,QAAQ,CAACtB,KAAK,CAAC,CAAC;EAC/D;EAEA,IAAIE,IAAI,KAAK,UAAU,EAAE;IACvB,OAAO,IAAIlB,QAAQ,CAACgB,KAAK,CAACQ,QAAQ,EAAER,KAAK,CAACS,SAAS,CAAC;EACtD;EAEA,IAAIP,IAAI,KAAK,WAAW,EAAE;IACxB,OAAO,IAAIf,SAAS,CAACa,KAAK,CAACU,OAAO,EAAEV,KAAK,CAACW,WAAW,CAAC;EACxD;EAEA,IAAIT,IAAI,KAAK,MAAM,EAAE;IACnB,OAAO,IAAIU,IAAI,CAACZ,KAAK,CAAC;EACxB;EAEA,IAAIE,IAAI,KAAK,MAAM,EAAE;IACnB,OAAOrB,IAAI,CAAC0C,gBAAgB,CAACvB,KAAK,CAAC;EACrC;EAEA,IAAIE,IAAI,KAAK,UAAU,EAAE;IACvB,OAAOG,QAAQ;EACjB;EAEA,IAAIH,IAAI,KAAK,KAAK,EAAE;IAClB,OAAOsB,GAAG;EACZ;EAEAR,OAAO,CAACC,IAAI,CAAE,8BAA6Bf,IAAK,EAAC,CAAC;EAClD,OAAOF,KAAK;AACd,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}